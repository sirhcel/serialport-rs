#![allow(non_camel_case_types, dead_code)]

use std::io;
use std::os::unix::io::RawFd;
use std::slice;
use std::time::Duration;

use nix::poll::{PollFd, PollFlags};
#[cfg(target_os = "linux")]
use nix::sys::signal::SigSet;
#[cfg(target_os = "linux")]
use nix::sys::time::{TimeSpec, TimeValLike};

pub fn wait_read_fd(fd: RawFd, timeout: Duration) -> io::Result<()> {
    wait_fd(fd, PollFlags::POLLIN, timeout)
}

pub fn wait_write_fd(fd: RawFd, timeout: Duration) -> io::Result<()> {
    wait_fd(fd, PollFlags::POLLOUT, timeout)
}

fn wait_fd(fd: RawFd, events: PollFlags, timeout: Duration) -> io::Result<()> {
    use nix::errno::Errno::{EIO, EPIPE};

    let mut fd = PollFd::new(fd, events);

    let milliseconds = milliseconds_i64(timeout);
    #[cfg(target_os = "linux")]
    let wait_res = {
        let timespec = TimeSpec::milliseconds(milliseconds);
        nix::poll::ppoll(
            slice::from_mut(&mut fd),
            Some(timespec),
            Some(SigSet::empty()),
        )
    };
    #[cfg(not(target_os = "linux"))]
    let wait_res = nix::poll::poll(slice::from_mut(&mut fd), milliseconds as nix::libc::c_int);

    let wait = match wait_res {
        Ok(r) => r,
        Err(e) => return Err(io::Error::from(crate::Error::from(e))),
    };
    // All errors generated by poll or ppoll are already caught by the nix wrapper around libc, so
    // here we only need to check if there's at least 1 event
    if wait != 1 {
        return Err(io::Error::new(
            io::ErrorKind::TimedOut,
            "Operation timed out",
        ));
    }

    // Check the result of ppoll() by looking at the revents field
    match fd.revents() {
        Some(e) if e == events => return Ok(()),
        // If there was a hangout or invalid request
        Some(e) if e.contains(PollFlags::POLLHUP) || e.contains(PollFlags::POLLNVAL) => {
            return Err(io::Error::new(io::ErrorKind::BrokenPipe, EPIPE.desc()));
        }
        Some(_) | None => (),
    }

    Err(io::Error::new(io::ErrorKind::Other, EIO.desc()))
}

fn milliseconds_i64(duration: Duration) -> i64 {
    duration.as_secs() as i64 * 1000 + i64::from(duration.subsec_nanos()) / 1_000_000
}

#[cfg(test)]
mod test {
    use super::*;

    use nix::libc::c_int;

    // TODO: Harmonize with corresponding tests for Windows.
    fn monotonicity_test_durations() -> Vec<Duration> {
        vec![
            Duration::ZERO,
            Duration::from_nanos(1),
            Duration::from_millis(1),
            Duration::from_secs(1),
            Duration::from_secs(i16::MAX as u64 - 1),
            Duration::from_secs(i16::MAX as u64),
            Duration::from_secs(i16::MAX as u64 + 1),
            Duration::from_secs(i32::MAX as u64 - 1),
            Duration::from_secs(i32::MAX as u64),
            Duration::from_secs(i32::MAX as u64 + 1),
            Duration::from_secs(i64::MAX as u64 - 1),
            Duration::from_secs(i64::MAX as u64),
            Duration::from_secs(i64::MAX as u64 + 1),
            Duration::from_secs(u64::MAX - 1),
            Duration::from_secs(u64::MAX),
            Duration::from_secs(u64::MAX) + Duration::from_millis(1),
            Duration::MAX,
        ]
    }

    #[test]
    fn milliseconds_i64_as_c_int_is_monotonic() {
        let mut last = milliseconds_i64(Duration::ZERO) as c_int;

        for (i, d) in monotonicity_test_durations().iter().enumerate() {
            let next = milliseconds_i64(*d) as c_int;
            dbg!((i, d));
            assert!(
                next >= last,
                "{next} >= {last} failed for {d:?} at index {i}"
            );
            last = next;
        }
    }

    #[test]
    fn milliseconds_i64_as_c_int_zero_is_zero() {
        assert_eq!(0, milliseconds_i64(Duration::ZERO) as c_int);
    }

    #[test]
    fn milliseconds_i64_is_monotonic() {
        let mut last = milliseconds_i64(Duration::ZERO);

        for (i, d) in monotonicity_test_durations().iter().enumerate() {
            let next = milliseconds_i64(*d);
            dbg!((i, d));
            assert!(
                next >= last,
                "{next} >= {last} failed for {d:?} at index {i}"
            );
            last = next;
        }
    }

    #[test]
    fn milliseconds_i64_zero_is_zero() {
        assert_eq!(0, milliseconds_i64(Duration::ZERO));
    }
}
